package org.apache.struts.action;

import static java.util.Objects.requireNonNull;
import static org.apache.struts.Globals.*;

import java.util.Locale;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.struts.chain.contexts.ServletActionContext;
import org.apache.struts.util.MessageResources;
import org.apache.struts.util.ModuleUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.lang.Nullable;
import springing.struts1.controller.RequestTokenManager;

public abstract class Action {

  /**
   * Process the specified HTTP request, and create the corresponding HTTP
   * response (or forward to another web component that will create it), with
   * provision for handling exceptions thrown by the business logic. Return
   * an `ActionForward` instance describing where and how control should be
   * forwarded, or `null` if the response has already been completed.
   */
  public abstract @Nullable ActionForward execute(
    ActionMapping mapping,
    @Nullable ActionForm form,
    HttpServletRequest request,
    HttpServletResponse response
  ) throws Exception;

  /**
   * Adds the specified messages keys into the appropriate request attribute
   * for use by the `html:messages` tag (if messages="true" is set), if any
   * messages are required. Initialize the attribute if it has not already
   * been. Otherwise, ensure that the request attribute is not set.
   */
  protected void addMessages(
    HttpServletRequest request,
    @Nullable ActionMessages messages
  ) {
    if (messages == null) {
      return;
    }
    var requestMessages = (ActionMessages) request.getAttribute(MESSAGE_KEY);
    if (requestMessages == null) {
      requestMessages = new ActionMessages();
    }
    requestMessages.add(messages);
    saveMessages(request, requestMessages);
  }

  /**
   * Save the specified error messages keys into the appropriate request
   * attribute for use by the `html:errors` tag, if any messages are
   * required. Otherwise, ensure that the request attribute is not created.
   */
  protected void saveErrors(
    HttpServletRequest request,
    @Nullable ActionMessages errors
  ) {
    var empty = errors == null || errors.isEmpty();
    if (empty) {
      request.removeAttribute(ERROR_KEY);
    } else {
      request.setAttribute(ERROR_KEY, errors);
    }
  }

  /**
   * Save the specified messages keys into the appropriate request attribute
   * for use by the `html:messages` tag (if messages="true" is set), if any
   * messages are required. Otherwise, ensure that the request attribute is
   * not created.
   */
  protected void saveMessages(
    HttpServletRequest request,
    @Nullable ActionMessages messages
  ) {
    var empty = messages == null || messages.isEmpty();
    if (empty) {
      request.removeAttribute(MESSAGE_KEY);
    } else {
      request.setAttribute(MESSAGE_KEY, messages);
    }
  }

  /**
   * Return the user's currently selected Locale.
   */
  protected Locale getLocale(HttpServletRequest request) {
    return LocaleContextHolder.getLocale();
  }

  /**
   * Returns `true` if the current form's cancel button was pressed. This
   * method will check if the `Globals.CANCEL_KEY` request attribute has been
   * set, which normally occurs if the cancel button generated by `CancelTag`
   * was pressed by the user in the current request. If `true`, validation
   * performed by an `ActionForm#validate()` method will have been skipped by
   * the controller servlet.
   * Since Action 1.3.0, the mapping for a cancellable Action must also have
   * the new "cancellable" property set to true. If "cancellable" is not set,
   * and the magic Cancel token is found in the request, the standard
   * Composable Request Processor will throw an InvalidCancelException.
   */
  protected boolean isCancelled(HttpServletRequest request) {
    return request.getAttribute(CANCEL_KEY) != null;
  }

  /**
   * Return `true` if there is a transaction token stored in the user's current
   * session, and the value submitted as a request parameter with this action
   * matches it. Returns `false` under any of the following circumstances:
   * - No session associated with this request
   * - No transaction token saved in the session
   * - No transaction token included as a request parameter
   * - The included transaction token value does not match the transaction
   *   token in the user's session
   */
  protected boolean isTokenValid(HttpServletRequest request) {
    return requestTokenManager.isValid(request);
  }

  /**
   * Save a new transaction token in the user's current session, creating
   * a new session if necessary.
   */
  protected void saveToken(HttpServletRequest request) {
    getRequestTokenManager().save(request);
  }

  /**
   * Reset the saved transaction token in the user's session.
   * This indicates that transactional token checking will not be needed on the
   * next request that is submitted.
   */
  protected void resetToken(HttpServletRequest request) {
    getRequestTokenManager().reset(request);
  }

  public RequestTokenManager getRequestTokenManager() {
    if (requestTokenManager == null) throw new IllegalStateException(
      "The request token manager for this action is not set."
    );
    return requestTokenManager;
  }

  @Autowired
  public void setRequestTokenManager(RequestTokenManager requestTokenManager) {
    this.requestTokenManager = requestTokenManager;
  }

  private @Nullable RequestTokenManager requestTokenManager;

  /**
   * Return the default message resources for the current module.
   */
  protected MessageResources getResources(HttpServletRequest request) {
    return ModuleUtils.getCurrent().getMessageResources();
  }

  /**
   * Return the servlet instance to which we are attached.
   * **NOTE:**
   * The instance returned by this method is a dummy implementation of the
   * ActionServlet class, as the Spring framework's DispatchServlet is used
   * instead.
   */
  public ActionServlet getServlet() {
    if (servlet == null) throw new IllegalStateException(
      "The servlet instance should be set to a action instance."
    );
    return servlet;
  }

  /**
   * Set the servlet instance to which we are attached (if `servlet` is
   * non-null), or release any allocated resources (if `servlet` is null).
   */
  @Autowired
  public void setServlet(ActionServlet servlet) {
    this.servlet = servlet;
  }

  protected @Nullable ActionServlet servlet;

  @Autowired
  public void setStrutsRequestContext(
    ServletActionContext servletActionContext
  ) {
    this.servletActionContext = servletActionContext;
  }

  public ServletActionContext getStrutsRequestContext() {
    return requireNonNull(servletActionContext);
  }

  private @Nullable ServletActionContext servletActionContext;
}
